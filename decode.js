function encode(input) {
    return (
        /**Строка: hello */
        [...input]
            /**
             * Проходимся по каждому элементу строки,
             * берём юникод элемента по 0 индексу
             * Возвращаем массив картежей, где
             * ["юникод элемента", "индекс элемента"]
             * @return [ [ 104, 0 ], [ 101, 1 ], [ 108, 2 ], [ 108, 3 ], [ 111, 4 ] ]
             */
            .map((x, i) => {
                return [x.charCodeAt(), i]
            })
            /**
             * Метод sort() по умолчанию преобразовывает
             * все элементы в строку и сортирует на основе
             * порядковых точек unicode
             * @return [ [ 101, 1 ], [ 104, 0 ], [ 108, 2 ], [ 108, 3 ], [ 111, 4 ] ]
             */
            .sort()
            /**
             * Далее все массивы раскрываются
             * и отсортированные элементы помещаются в
             * основной массив через запятую
             * @return [ 101, 1, 104, 0, 108, 2, 108, 3, 111, 4 ]
             */
            .flatMap((x) => x)
            /**
             * Далее массив склеивается в строку
             * через точку
             * @return 101.1.104.0.108.2.108.3.111.4
             */
            .join(".")
            /**
             * в строке находятся
             * все символы и возвращается массив совпадений:
             * @return [
                '1', '0', '1', '.', '1', '.',
                '1', '0', '4', '.', '0', '.',
                '1', '0', '8', '.', '2', '.',
                '1', '0', '8', '.', '3', '.',
                '1', '1', '1', '.', '4'
                ]
             */
            .match(/./g)
            /**
             * В цикле происходит проверка каждого элемента
             * если элемент равен ".", тогда создаётся массив
             * длинной из 1 элемента, если любой другой элемент,
             * тогда длинна массива определяется как 2 + (x * 2),
             * после этого массив заполняется элементами, состоящими
             * из остатков по делению от (1 + индекс элемента).
             * После того, цикл пройдётся по всем элементам и создат массивы,
             * flatMap развернет все массивы в 1 массив
             */
            .flatMap((x, i) =>
                new Array(x == "." ? 1 : 2 + x * 2).fill((1 + i) % 2)
            )
            /**
             * Метод соеденит все элементы массива в строку
             */
            .join("")
            /**
             * регулярное выражение ищет послеовательность нулей и единиц
             * т.е. последовательность, где 0 или 1 повторяются 1 и более раз
             * например, 0001011 найдёт: [000, 1, 0, 11]
             * в данном случае, регулярное выражение найдёт из строки
             * 111100111101111011110011111111110110111100111111111111111111011111101111
             * 00111111111111111111011111111011110000111101111111111
             * найдёт следующее:
             * @return [
                '1111',               '00',
                '1111',               '0',
                '1111',               '0',
                '1111',               '00',
                '1111111111',         '0',
                '11',                 '0',
                '1111',               '00',
                '111111111111111111', '0',
                '111111',             '0',
                '1111',               '00',
                '111111111111111111', '0',
                '11111111',           '0',
                '1111',               '0000',
                '1111',               '0',
                '1111111111'
                ]
                далее, метод replace в цикле проходится по каждому элементу
                и проверяет, если элемент возвращает true, тогда он заменяется на точку + его длинна,
                иначе он заменяется на тире.

                Т.е. все единицы заменяются на точку + их количество,
                а все нули заменяются на "-" + их количество
                
                в итоге получается строка:

                .4-2.4-1.4-1.4-2.10-1.2-1.4-2.18-1.6-1.4-2.18-1.8-1.4-4.4-1.10
             */
            .replace(/(([01])\2*)/g, (x) => `${+x ? "." : "-"}${x.length}`)
    )
}

function decode(input) {
    const string = input

    return (
        string
            /**
             * Найдём вхождение всех последовательностей,
             * которые начинаются с "." c последующим числом
             * или начинаются с "-" с последующим числом
             */
            .match(/[.-]\d+/g)
            .reduce((acc, x) => {
                /**
                 * Получаем длинну массива
                 */
                const n = [...x].slice(1).reduce((a, b) => a + b)
                /**
                 * Преобразуем каждый найденный элемент в массив
                 */
                const a =
                    x[0] === "." ? new Array(+n).fill(1) : new Array(+n).fill(0)
                if (a.length === 1) {
                    acc.push(".")
                } else {
                    /**
                     * решаем линейное уровнение, чтобы найти значение элемента
                     */
                    acc.push((a.length - 2) / 2)
                }

                return acc
            }, [])
            .join("")
            .match(/(\d+)\.(\d+)/g)
            .reduce((acc, el) => {
                const matches = el.match(/(\d+)\.(\d+)/)
                acc.push([+matches[1], +matches[2]])
                return acc
            }, [])
            .sort((a, b) => a[1] - b[1])
            .reduce((acc, el) => {
                acc += String.fromCodePoint(el[0])
                return acc
            }, "")
    )
}

console.log(decode(encode("привет")))
console.log(decode(encode("зашифрованная фраза")))
console.log(
    decode(encode("Какой-то оооочень, ну просто очень большой и сложный текст"))
)
console.log(
    decode(
        encode(
            "Мой телеграмм: @Jops_Stiven, мой вк: https://vk.com/danil_sobolev1998, номер телефона: 8-937-697-59-01."
        )
    )
)
